{"ast":null,"code":"// ==ClosureCompiler==\n// @output_file_name default.js\n// @compilation_level SIMPLE_OPTIMIZATIONS\n// ==/ClosureCompiler==\n\n/**\n * @author: Tobias Nickel\n * @created: 06.04.2015\n * I needed a small xmlparser chat can be used in a worker.\n */\n\n/**\n * @typedef tNode \n * @property {string} tagName \n * @property {object} [attributes] \n * @property {tNode|string|number[]} children \n **/\n\n/**\n * parseXML / html into a DOM Object. with no validation and some failur tolerance\n * @param {string} S your XML to parse\n * @param options {object} all other options:\n * searchId {string} the id of a single element, that should be returned. using this will increase the speed rapidly\n * filter {function} filter method, as you know it from Array.filter. but is goes throw the DOM.\n\n * @return {tNode[]}\n */\nfunction tXml(S, options) {\n  \"use strict\";\n\n  options = options || {};\n  var pos = options.pos || 0;\n  var openBracket = \"<\";\n  var openBracketCC = \"<\".charCodeAt(0);\n  var closeBracket = \">\";\n  var closeBracketCC = \">\".charCodeAt(0);\n  var minus = \"-\";\n  var minusCC = \"-\".charCodeAt(0);\n  var slash = \"/\";\n  var slashCC = \"/\".charCodeAt(0);\n  var exclamation = '!';\n  var exclamationCC = '!'.charCodeAt(0);\n  var singleQuote = \"'\";\n  var singleQuoteCC = \"'\".charCodeAt(0);\n  var doubleQuote = '\"';\n  var doubleQuoteCC = '\"'.charCodeAt(0);\n  /**\n   * parsing a list of entries\n   */\n\n  function parseChildren() {\n    var children = [];\n\n    while (S[pos]) {\n      if (S.charCodeAt(pos) == openBracketCC) {\n        if (S.charCodeAt(pos + 1) === slashCC) {\n          pos = S.indexOf(closeBracket, pos);\n          if (pos + 1) pos += 1;\n          return children;\n        } else if (S.charCodeAt(pos + 1) === exclamationCC) {\n          if (S.charCodeAt(pos + 2) == minusCC) {\n            //comment support\n            while (pos !== -1 && !(S.charCodeAt(pos) === closeBracketCC && S.charCodeAt(pos - 1) == minusCC && S.charCodeAt(pos - 2) == minusCC && pos != -1)) {\n              pos = S.indexOf(closeBracket, pos + 1);\n            }\n\n            if (pos === -1) {\n              pos = S.length;\n            }\n          } else {\n            // doctypesupport\n            pos += 2;\n\n            while (S.charCodeAt(pos) !== closeBracketCC && S[pos]) {\n              pos++;\n            }\n          }\n\n          pos++;\n          continue;\n        }\n\n        var node = parseNode();\n        children.push(node);\n      } else {\n        var text = parseText();\n        if (text.trim().length > 0) children.push(text);\n        pos++;\n      }\n    }\n\n    return children;\n  }\n  /**\n   *    returns the text outside of texts until the first '<'\n   */\n\n\n  function parseText() {\n    var start = pos;\n    pos = S.indexOf(openBracket, pos) - 1;\n    if (pos === -2) pos = S.length;\n    return S.slice(start, pos + 1);\n  }\n  /**\n   *    returns text until the first nonAlphebetic letter\n   */\n\n\n  var nameSpacer = '\\n\\t>/= ';\n\n  function parseName() {\n    var start = pos;\n\n    while (nameSpacer.indexOf(S[pos]) === -1 && S[pos]) {\n      pos++;\n    }\n\n    return S.slice(start, pos);\n  }\n  /**\n   *    is parsing a node, including tagName, Attributes and its children,\n   * to parse children it uses the parseChildren again, that makes the parsing recursive\n   */\n\n\n  var NoChildNodes = options.noChildNodes || ['img', 'br', 'input', 'meta', 'link'];\n\n  function parseNode() {\n    pos++;\n    var tagName = parseName();\n    var attributes = {};\n    var children = []; // parsing attributes\n\n    while (S.charCodeAt(pos) !== closeBracketCC && S[pos]) {\n      var c = S.charCodeAt(pos);\n\n      if (c > 64 && c < 91 || c > 96 && c < 123) {\n        //if('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.indexOf(S[pos])!==-1 ){\n        var name = parseName(); // search beginning of the string\n\n        var code = S.charCodeAt(pos);\n\n        while (code && code !== singleQuoteCC && code !== doubleQuoteCC && !(code > 64 && code < 91 || code > 96 && code < 123) && code !== closeBracketCC) {\n          pos++;\n          code = S.charCodeAt(pos);\n        }\n\n        if (code === singleQuoteCC || code === doubleQuoteCC) {\n          var value = parseString();\n\n          if (pos === -1) {\n            return {\n              tagName: tagName,\n              attributes: attributes,\n              children: children\n            };\n          }\n        } else {\n          value = null;\n          pos--;\n        }\n\n        attributes[name] = value;\n      }\n\n      pos++;\n    } // optional parsing of children\n\n\n    if (S.charCodeAt(pos - 1) !== slashCC) {\n      if (tagName == \"script\") {\n        var start = pos + 1;\n        pos = S.indexOf('</script>', pos);\n        children = [S.slice(start, pos - 1)];\n        pos += 9;\n      } else if (tagName == \"style\") {\n        var start = pos + 1;\n        pos = S.indexOf('</style>', pos);\n        children = [S.slice(start, pos - 1)];\n        pos += 8;\n      } else if (NoChildNodes.indexOf(tagName) == -1) {\n        pos++;\n        children = parseChildren(name);\n      }\n    } else {\n      pos++;\n    }\n\n    return {\n      tagName: tagName,\n      attributes: attributes,\n      children: children\n    };\n  }\n  /**\n   *    is parsing a string, that starts with a char and with the same usually  ' or \"\n   */\n\n\n  function parseString() {\n    var startChar = S[pos];\n    var startpos = ++pos;\n    pos = S.indexOf(startChar, startpos);\n    return S.slice(startpos, pos);\n  }\n  /**\n   *\n   */\n\n\n  function findElements() {\n    var r = new RegExp('\\\\s' + options.attrName + '\\\\s*=[\\'\"]' + options.attrValue + '[\\'\"]').exec(S);\n\n    if (r) {\n      return r.index;\n    } else {\n      return -1;\n    }\n  }\n\n  var out = null;\n\n  if (options.attrValue !== undefined) {\n    options.attrName = options.attrName || 'id';\n    var out = [];\n\n    while ((pos = findElements()) !== -1) {\n      pos = S.lastIndexOf('<', pos);\n\n      if (pos !== -1) {\n        out.push(parseNode());\n      }\n\n      S = S.substr(pos);\n      pos = 0;\n    }\n  } else if (options.parseNode) {\n    out = parseNode();\n  } else {\n    out = parseChildren();\n  }\n\n  if (options.filter) {\n    out = tXml.filter(out, options.filter);\n  }\n\n  if (options.setPos) {\n    out.pos = pos;\n  }\n\n  return out;\n}\n/**\n * transform the DomObject to an object that is like the object of PHPs simplexmp_load_*() methods.\n * this format helps you to write that is more likely to keep your programm working, even if there a small changes in the XML schema.\n * be aware, that it is not possible to reproduce the original xml from a simplified version, because the order of elements is not saved.\n * therefore your programm will be more flexible and easyer to read.\n *\n * @param {tNode[]} children the childrenList\n */\n\n\ntXml.simplify = function simplify(children) {\n  var out = {};\n\n  if (!children.length) {\n    return '';\n  }\n\n  if (children.length === 1 && typeof children[0] == 'string') {\n    return children[0];\n  } // map each object\n\n\n  children.forEach(function (child) {\n    if (typeof child !== 'object') {\n      return;\n    }\n\n    if (!out[child.tagName]) out[child.tagName] = [];\n    var kids = tXml.simplify(child.children || []);\n    out[child.tagName].push(kids);\n\n    if (child.attributes) {\n      kids._attributes = child.attributes;\n    }\n  });\n\n  for (var i in out) {\n    if (out[i].length == 1) {\n      out[i] = out[i][0];\n    }\n  }\n\n  return out;\n};\n/**\n * behaves the same way as Array.filter, if the filter method return true, the element is in the resultList\n * @params children{Array} the children of a node\n * @param f{function} the filter method\n */\n\n\ntXml.filter = function (children, f) {\n  var out = [];\n  children.forEach(function (child) {\n    if (typeof child === 'object' && f(child)) out.push(child);\n\n    if (child.children) {\n      var kids = tXml.filter(child.children, f);\n      out = out.concat(kids);\n    }\n  });\n  return out;\n};\n/**\n * stringify a previously parsed string object.\n * this is useful,\n *  1. to remove whitespaces\n * 2. to recreate xml data, with some changed data.\n * @param {tNode} O the object to Stringify\n */\n\n\ntXml.stringify = function TOMObjToXML(O) {\n  var out = '';\n\n  function writeChildren(O) {\n    if (O) for (var i = 0; i < O.length; i++) {\n      if (typeof O[i] == 'string') {\n        out += O[i].trim();\n      } else {\n        writeNode(O[i]);\n      }\n    }\n  }\n\n  function writeNode(N) {\n    out += \"<\" + N.tagName;\n\n    for (var i in N.attributes) {\n      if (N.attributes[i] === null) {\n        out += ' ' + i;\n      } else if (N.attributes[i].indexOf('\"') === -1) {\n        out += ' ' + i + '=\"' + N.attributes[i].trim() + '\"';\n      } else {\n        out += ' ' + i + \"='\" + N.attributes[i].trim() + \"'\";\n      }\n    }\n\n    out += '>';\n    writeChildren(N.children);\n    out += '</' + N.tagName + '>';\n  }\n\n  writeChildren(O);\n  return out;\n};\n/**\n * use this method to read the textcontent, of some node.\n * It is great if you have mixed content like:\n * this text has some <b>big</b> text and a <a href=''>link</a>\n * @return {string}\n */\n\n\ntXml.toContentString = function (tDom) {\n  if (Array.isArray(tDom)) {\n    var out = '';\n    tDom.forEach(function (e) {\n      out += ' ' + tXml.toContentString(e);\n      out = out.trim();\n    });\n    return out;\n  } else if (typeof tDom === 'object') {\n    return tXml.toContentString(tDom.children);\n  } else {\n    return ' ' + tDom;\n  }\n};\n\ntXml.getElementById = function (S, id, simplified) {\n  var out = tXml(S, {\n    attrValue: id\n  });\n  return simplified ? tXml.simplify(out) : out[0];\n};\n/**\n * A fast parsing method, that not realy finds by classname,\n * more: the class attribute contains XXX\n * @param\n */\n\n\ntXml.getElementsByClassName = function (S, classname, simplified) {\n  var out = tXml(S, {\n    attrName: 'class',\n    attrValue: '[a-zA-Z0-9- ]*' + classname + '[a-zA-Z0-9- ]*'\n  });\n  return simplified ? tXml.simplify(out) : out;\n};\n\ntXml.parseStream = function (stream, offset) {\n  if (typeof offset === 'string') {\n    offset = offset.length + 2;\n  }\n\n  if (typeof stream === 'string') {\n    var fs = require('fs');\n\n    stream = fs.createReadStream(stream, {\n      start: offset\n    });\n    offset = 0;\n  }\n\n  var position = offset;\n  var data = '';\n  stream.on('data', function (chunk) {\n    data += chunk;\n    var lastPos = 0;\n\n    do {\n      position = data.indexOf('<', position) + 1;\n\n      if (!position) {\n        position = lastPos;\n        return;\n      }\n\n      if (data[position + 1] === '/') {\n        position = position + 1;\n        lastPos = pos;\n        continue;\n      }\n\n      var res = tXml(data, {\n        pos: position - 1,\n        parseNode: true,\n        setPos: true\n      });\n      position = res.pos;\n\n      if (position > data.length - 1 || position < lastPos) {\n        data = data.slice(lastPos);\n        position = 0;\n        lastPos = 0;\n        return;\n      } else {\n        stream.emit('xml', res);\n        lastPos = position;\n      }\n    } while (1);\n  });\n  stream.on('end', function () {\n    console.log('end');\n  });\n  return stream;\n};\n\ntXml.transformStream = function (offset) {\n  // require through here, so it will not get added to webpack/browserify\n  var through2 = require('through2');\n\n  if (typeof offset === 'string') {\n    offset = offset.length + 2;\n  }\n\n  var position = offset || 0;\n  var data = '';\n  var stream = through2({\n    readableObjectMode: true\n  }, function (chunk, enc, callback) {\n    data += chunk;\n    var lastPos = 0;\n\n    do {\n      position = data.indexOf('<', position) + 1;\n\n      if (!position) {\n        position = lastPos;\n        return callback();\n        ;\n      }\n\n      if (data[position + 1] === '/') {\n        position = position + 1;\n        lastPos = pos;\n        continue;\n      }\n\n      var res = tXml(data, {\n        pos: position - 1,\n        parseNode: true,\n        setPos: true\n      });\n      position = res.pos;\n\n      if (position > data.length - 1 || position < lastPos) {\n        data = data.slice(lastPos);\n        position = 0;\n        return callback();\n        ;\n      } else {\n        this.push(res);\n        lastPos = position;\n      }\n    } while (1);\n\n    callback();\n  });\n  return stream;\n};\n\nif ('object' === typeof module) {\n  module.exports = tXml;\n  tXml.xml = tXml;\n} //console.clear();\n//console.log('here:',tXml.getElementById('<some><xml id=\"test\">dada</xml><that id=\"test\">value</that></some>','test'));\n//console.log('here:',tXml.getElementsByClassName('<some><xml id=\"test\" class=\"sdf test jsalf\">dada</xml><that id=\"test\">value</that></some>','test'));\n\n/*\nconsole.clear();\ntXml(d,'content');\n //some testCode\nvar s = document.body.innerHTML.toLowerCase();\nvar start = new Date().getTime();\nvar o = tXml(s,'content');\nvar end = new Date().getTime();\n//console.log(JSON.stringify(o,undefined,'\\t'));\nconsole.log(\"MILLISECONDS\",end-start);\nvar nodeCount=document.querySelectorAll('*').length;\nconsole.log('node count',nodeCount);\nconsole.log(\"speed:\",(1000/(end-start))*nodeCount,'Nodes / second')\n//console.log(JSON.stringify(tXml('<html><head><title>testPage</title></head><body><h1>TestPage</h1><p>this is a <b>test</b>page</p></body></html>'),undefined,'\\t'));\nvar p = new DOMParser();\nvar s2='<body>'+s+'</body>'\nvar start2= new Date().getTime();\nvar o2 = p.parseFromString(s2,'text/html').querySelector('#content')\nvar end2=new Date().getTime();\nconsole.log(\"MILLISECONDS\",end2-start2);\n// */","map":{"version":3,"sources":["/Users/charlotteweil1/Projets/Viz/gobiTraining/node_modules/txml/tXml.js"],"names":["tXml","S","options","pos","openBracket","openBracketCC","charCodeAt","closeBracket","closeBracketCC","minus","minusCC","slash","slashCC","exclamation","exclamationCC","singleQuote","singleQuoteCC","doubleQuote","doubleQuoteCC","parseChildren","children","indexOf","length","node","parseNode","push","text","parseText","trim","start","slice","nameSpacer","parseName","NoChildNodes","noChildNodes","tagName","attributes","c","name","code","value","parseString","startChar","startpos","findElements","r","RegExp","attrName","attrValue","exec","index","out","undefined","lastIndexOf","substr","filter","setPos","simplify","forEach","child","kids","_attributes","i","f","concat","stringify","TOMObjToXML","O","writeChildren","writeNode","N","toContentString","tDom","Array","isArray","e","getElementById","id","simplified","getElementsByClassName","classname","parseStream","stream","offset","fs","require","createReadStream","position","data","on","chunk","lastPos","res","emit","console","log","transformStream","through2","readableObjectMode","enc","callback","module","exports","xml"],"mappings":"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","sourcesContent":["// ==ClosureCompiler==\n// @output_file_name default.js\n// @compilation_level SIMPLE_OPTIMIZATIONS\n// ==/ClosureCompiler==\n\n/**\n * @author: Tobias Nickel\n * @created: 06.04.2015\n * I needed a small xmlparser chat can be used in a worker.\n */\n\n/**\n * @typedef tNode \n * @property {string} tagName \n * @property {object} [attributes] \n * @property {tNode|string|number[]} children \n **/\n\n/**\n * parseXML / html into a DOM Object. with no validation and some failur tolerance\n * @param {string} S your XML to parse\n * @param options {object} all other options:\n * searchId {string} the id of a single element, that should be returned. using this will increase the speed rapidly\n * filter {function} filter method, as you know it from Array.filter. but is goes throw the DOM.\n\n * @return {tNode[]}\n */\nfunction tXml(S, options) {\n    \"use strict\";\n    options = options || {};\n\n    var pos = options.pos || 0;\n\n    var openBracket = \"<\";\n    var openBracketCC = \"<\".charCodeAt(0);\n    var closeBracket = \">\";\n    var closeBracketCC = \">\".charCodeAt(0);\n    var minus = \"-\";\n    var minusCC = \"-\".charCodeAt(0);\n    var slash = \"/\";\n    var slashCC = \"/\".charCodeAt(0);\n    var exclamation = '!';\n    var exclamationCC = '!'.charCodeAt(0);\n    var singleQuote = \"'\";\n    var singleQuoteCC = \"'\".charCodeAt(0);\n    var doubleQuote = '\"';\n    var doubleQuoteCC = '\"'.charCodeAt(0);\n\n    /**\n     * parsing a list of entries\n     */\n    function parseChildren() {\n        var children = [];\n        while (S[pos]) {\n            if (S.charCodeAt(pos) == openBracketCC) {\n                if (S.charCodeAt(pos + 1) === slashCC) {\n                    pos = S.indexOf(closeBracket, pos);\n                    if (pos + 1) pos += 1\n                    return children;\n                } else if (S.charCodeAt(pos + 1) === exclamationCC) {\n                    if (S.charCodeAt(pos + 2) == minusCC) {\n                        //comment support\n                        while (pos !== -1 && !(S.charCodeAt(pos) === closeBracketCC && S.charCodeAt(pos - 1) == minusCC && S.charCodeAt(pos - 2) == minusCC && pos != -1)) {\n                            pos = S.indexOf(closeBracket, pos + 1);\n                        }\n                        if (pos === -1) {\n                            pos = S.length\n                        }\n                    } else {\n                        // doctypesupport\n                        pos += 2;\n                        while (S.charCodeAt(pos) !== closeBracketCC && S[pos]) {\n                            pos++;\n                        }\n                    }\n                    pos++;\n                    continue;\n                }\n                var node = parseNode();\n                children.push(node);\n            } else {\n                var text = parseText()\n                if (text.trim().length > 0)\n                    children.push(text);\n                pos++;\n            }\n        }\n        return children;\n    }\n\n    /**\n     *    returns the text outside of texts until the first '<'\n     */\n    function parseText() {\n        var start = pos;\n        pos = S.indexOf(openBracket, pos) - 1;\n        if (pos === -2)\n            pos = S.length;\n        return S.slice(start, pos + 1);\n    }\n    /**\n     *    returns text until the first nonAlphebetic letter\n     */\n    var nameSpacer = '\\n\\t>/= ';\n\n    function parseName() {\n        var start = pos;\n        while (nameSpacer.indexOf(S[pos]) === -1 && S[pos]) {\n            pos++;\n        }\n        return S.slice(start, pos);\n    }\n    /**\n     *    is parsing a node, including tagName, Attributes and its children,\n     * to parse children it uses the parseChildren again, that makes the parsing recursive\n     */\n    var NoChildNodes = options.noChildNodes || ['img', 'br', 'input', 'meta', 'link'];\n\n    function parseNode() {\n        pos++;\n        const tagName = parseName();\n        const attributes = {};\n        let children = [];\n\n        // parsing attributes\n        while (S.charCodeAt(pos) !== closeBracketCC && S[pos]) {\n            var c = S.charCodeAt(pos);\n            if ((c > 64 && c < 91) || (c > 96 && c < 123)) {\n                //if('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.indexOf(S[pos])!==-1 ){\n                var name = parseName();\n                // search beginning of the string\n                var code = S.charCodeAt(pos);\n                while (code && code !== singleQuoteCC && code !== doubleQuoteCC && !((code > 64 && code < 91) || (code > 96 && code < 123)) && code !== closeBracketCC) {\n                    pos++;\n                    code = S.charCodeAt(pos);\n                }\n                if (code === singleQuoteCC || code === doubleQuoteCC) {\n                    var value = parseString();\n                    if (pos === -1) {\n                        return {\n                            tagName,\n                            attributes,\n                            children,\n                        };\n                    }\n                } else {\n                    value = null;\n                    pos--;\n                }\n                attributes[name] = value;\n            }\n            pos++;\n        }\n        // optional parsing of children\n        if (S.charCodeAt(pos - 1) !== slashCC) {\n            if (tagName == \"script\") {\n                var start = pos + 1;\n                pos = S.indexOf('</script>', pos);\n                children = [S.slice(start, pos - 1)];\n                pos += 9;\n            } else if (tagName == \"style\") {\n                var start = pos + 1;\n                pos = S.indexOf('</style>', pos);\n                children = [S.slice(start, pos - 1)];\n                pos += 8;\n            } else if (NoChildNodes.indexOf(tagName) == -1) {\n                pos++;\n                children = parseChildren(name);\n            }\n        } else {\n            pos++;\n        }\n        return {\n            tagName,\n            attributes,\n            children,\n        };\n    }\n\n    /**\n     *    is parsing a string, that starts with a char and with the same usually  ' or \"\n     */\n\n    function parseString() {\n        var startChar = S[pos];\n        var startpos = ++pos;\n        pos = S.indexOf(startChar, startpos)\n        return S.slice(startpos, pos);\n    }\n\n    /**\n     *\n     */\n    function findElements() {\n        var r = new RegExp('\\\\s' + options.attrName + '\\\\s*=[\\'\"]' + options.attrValue + '[\\'\"]').exec(S)\n        if (r) {\n            return r.index;\n        } else {\n            return -1;\n        }\n    }\n\n    var out = null;\n    if (options.attrValue !== undefined) {\n        options.attrName = options.attrName || 'id';\n        var out = [];\n\n        while ((pos = findElements()) !== -1) {\n            pos = S.lastIndexOf('<', pos);\n            if (pos !== -1) {\n                out.push(parseNode());\n            }\n            S = S.substr(pos);\n            pos = 0;\n        }\n    } else if (options.parseNode) {\n        out = parseNode()\n    } else {\n        out = parseChildren();\n    }\n\n    if (options.filter) {\n        out = tXml.filter(out, options.filter);\n    }\n\n    if (options.setPos) {\n        out.pos = pos;\n    }\n\n    return out;\n}\n\n/**\n * transform the DomObject to an object that is like the object of PHPs simplexmp_load_*() methods.\n * this format helps you to write that is more likely to keep your programm working, even if there a small changes in the XML schema.\n * be aware, that it is not possible to reproduce the original xml from a simplified version, because the order of elements is not saved.\n * therefore your programm will be more flexible and easyer to read.\n *\n * @param {tNode[]} children the childrenList\n */\ntXml.simplify = function simplify(children) {\n    var out = {};\n    if (!children.length) {\n        return '';\n    }\n\n    if (children.length === 1 && typeof children[0] == 'string') {\n        return children[0];\n    }\n    // map each object\n    children.forEach(function(child) {\n        if (typeof child !== 'object') {\n            return;\n        }\n        if (!out[child.tagName])\n            out[child.tagName] = [];\n        var kids = tXml.simplify(child.children||[]);\n        out[child.tagName].push(kids);\n        if (child.attributes) {\n            kids._attributes = child.attributes;\n        }\n    });\n\n    for (var i in out) {\n        if (out[i].length == 1) {\n            out[i] = out[i][0];\n        }\n    }\n\n    return out;\n};\n\n/**\n * behaves the same way as Array.filter, if the filter method return true, the element is in the resultList\n * @params children{Array} the children of a node\n * @param f{function} the filter method\n */\ntXml.filter = function(children, f) {\n    var out = [];\n    children.forEach(function(child) {\n        if (typeof(child) === 'object' && f(child)) out.push(child);\n        if (child.children) {\n            var kids = tXml.filter(child.children, f);\n            out = out.concat(kids);\n        }\n    });\n    return out;\n};\n\n/**\n * stringify a previously parsed string object.\n * this is useful,\n *  1. to remove whitespaces\n * 2. to recreate xml data, with some changed data.\n * @param {tNode} O the object to Stringify\n */\ntXml.stringify = function TOMObjToXML(O) {\n    var out = '';\n\n    function writeChildren(O) {\n        if (O)\n            for (var i = 0; i < O.length; i++) {\n                if (typeof O[i] == 'string') {\n                    out += O[i].trim();\n                } else {\n                    writeNode(O[i]);\n                }\n            }\n    }\n\n    function writeNode(N) {\n        out += \"<\" + N.tagName;\n        for (var i in N.attributes) {\n            if (N.attributes[i] === null) {\n                out += ' ' + i;\n            } else if (N.attributes[i].indexOf('\"') === -1) {\n                out += ' ' + i + '=\"' + N.attributes[i].trim() + '\"';\n            } else {\n                out += ' ' + i + \"='\" + N.attributes[i].trim() + \"'\";\n            }\n        }\n        out += '>';\n        writeChildren(N.children);\n        out += '</' + N.tagName + '>';\n    }\n    writeChildren(O);\n\n    return out;\n};\n\n\n/**\n * use this method to read the textcontent, of some node.\n * It is great if you have mixed content like:\n * this text has some <b>big</b> text and a <a href=''>link</a>\n * @return {string}\n */\ntXml.toContentString = function(tDom) {\n    if (Array.isArray(tDom)) {\n        var out = '';\n        tDom.forEach(function(e) {\n            out += ' ' + tXml.toContentString(e);\n            out = out.trim();\n        });\n        return out;\n    } else if (typeof tDom === 'object') {\n        return tXml.toContentString(tDom.children)\n    } else {\n        return ' ' + tDom;\n    }\n};\n\ntXml.getElementById = function(S, id, simplified) {\n    var out = tXml(S, {\n        attrValue: id\n    });\n    return simplified ? tXml.simplify(out) : out[0];\n};\n/**\n * A fast parsing method, that not realy finds by classname,\n * more: the class attribute contains XXX\n * @param\n */\ntXml.getElementsByClassName = function(S, classname, simplified) {\n    const out = tXml(S, {\n        attrName: 'class',\n        attrValue: '[a-zA-Z0-9- ]*' + classname + '[a-zA-Z0-9- ]*'\n    });\n    return simplified ? tXml.simplify(out) : out;\n};\n\ntXml.parseStream = function(stream, offset) {\n    if (typeof offset === 'string') {\n        offset = offset.length + 2;\n    }\n    if (typeof stream === 'string') {\n        var fs = require('fs');\n        stream = fs.createReadStream(stream, { start: offset });\n        offset = 0;\n    }\n\n    var position = offset;\n    var data = '';\n    stream.on('data', function(chunk) {\n        data += chunk;\n        var lastPos = 0;\n        do {\n            position = data.indexOf('<', position) + 1;\n            if(!position) {\n                position = lastPos;\n                return;\n            }\n            if (data[position + 1] === '/') {\n                position = position + 1;\n                lastPos = pos;\n                continue;\n            }\n            var res = tXml(data, { pos: position-1, parseNode: true, setPos: true });\n            position = res.pos;\n            if (position > (data.length - 1) || position < lastPos) {\n                data = data.slice(lastPos);\n                position = 0;\n                lastPos = 0;\n                return;\n            } else {\n                stream.emit('xml', res);\n                lastPos = position;\n            }\n        } while (1);\n    });\n    stream.on('end', function() {\n        console.log('end')\n    });\n    return stream;\n}\n\ntXml.transformStream = function (offset) {\n    // require through here, so it will not get added to webpack/browserify\n    const through2 = require('through2');\n    if (typeof offset === 'string') {\n        offset = offset.length + 2;\n    }\n\n    var position = offset || 0;\n    var data = '';\n    const stream = through2({ readableObjectMode: true }, function (chunk, enc, callback) {\n        data += chunk;\n        var lastPos = 0;\n        do {\n            position = data.indexOf('<', position) + 1;\n            if (!position) {\n                position = lastPos;\n                return callback();;\n            }\n            if (data[position + 1] === '/') {\n                position = position + 1;\n                lastPos = pos;\n                continue;\n            }\n            var res = tXml(data, { pos: position - 1, parseNode: true, setPos: true });\n            position = res.pos;\n            if (position > (data.length - 1) || position < lastPos) {\n                data = data.slice(lastPos);\n                position = 0;\n                return callback();;\n            } else {\n                this.push(res);\n                lastPos = position;\n            }\n        } while (1);\n        callback();\n    });\n\n    return stream;\n}\n\nif ('object' === typeof module) {\n    module.exports = tXml;\n    tXml.xml = tXml;\n}\n//console.clear();\n//console.log('here:',tXml.getElementById('<some><xml id=\"test\">dada</xml><that id=\"test\">value</that></some>','test'));\n//console.log('here:',tXml.getElementsByClassName('<some><xml id=\"test\" class=\"sdf test jsalf\">dada</xml><that id=\"test\">value</that></some>','test'));\n\n/*\nconsole.clear();\ntXml(d,'content');\n //some testCode\nvar s = document.body.innerHTML.toLowerCase();\nvar start = new Date().getTime();\nvar o = tXml(s,'content');\nvar end = new Date().getTime();\n//console.log(JSON.stringify(o,undefined,'\\t'));\nconsole.log(\"MILLISECONDS\",end-start);\nvar nodeCount=document.querySelectorAll('*').length;\nconsole.log('node count',nodeCount);\nconsole.log(\"speed:\",(1000/(end-start))*nodeCount,'Nodes / second')\n//console.log(JSON.stringify(tXml('<html><head><title>testPage</title></head><body><h1>TestPage</h1><p>this is a <b>test</b>page</p></body></html>'),undefined,'\\t'));\nvar p = new DOMParser();\nvar s2='<body>'+s+'</body>'\nvar start2= new Date().getTime();\nvar o2 = p.parseFromString(s2,'text/html').querySelector('#content')\nvar end2=new Date().getTime();\nconsole.log(\"MILLISECONDS\",end2-start2);\n// */\n"]},"metadata":{},"sourceType":"script"}