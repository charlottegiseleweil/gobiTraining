{"ast":null,"code":"var _jsxFileName = \"/Users/charlotteweil1/Projets/Viz/gobiTraining/src/components/Map.js\";\nimport React from \"react\";\nimport L from \"leaflet\";\nimport shp from \"shpjs\";\nimport Container from \"react-bootstrap/Container\";\nimport Legend from \"./Legend\";\n\nconst parse_georaster = require(\"georaster\");\n\nconst GeoRasterLayer = require(\"georaster-layer-for-leaflet\"); // variables to hold the main map and all the layers displayed\n\n\nlet map;\nlet layers;\nlet updateChart;\n\nclass MainMap extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.updateLayers = () => {\n      this.props.chartIsLinked && updateChart([]);\n      layers.clearLayers();\n      this.props.selectedDatasets.forEach(id => {\n        let dataset = this.props.datasets[id];\n\n        switch (dataset.type) {\n          case \"shapefile\":\n            addShapefile(dataset, this.props.chartIsLinked);\n            break;\n\n          case \"tiles\":\n            addTiles(dataset);\n            break;\n\n          case \"raster\":\n            addRaster(dataset);\n            break;\n\n          default:\n        }\n      });\n    };\n\n    this.isDataSelected = () => {\n      return this.props.selectedDatasets.length > 0;\n    };\n\n    this.state = {};\n    updateChart = props.updateChart;\n  } // initialize the map\n\n\n  componentDidMount() {\n    // create base map\n    map = L.map(\"map\", {\n      center: this.props.baseMap.center,\n      zoom: this.props.baseMap.zoom,\n      layers: [L.tileLayer(this.props.baseMap.src, {\n        attribution: this.props.baseMap.attribution\n      })]\n    });\n    console.log(map);\n    layers = L.layerGroup().addTo(map);\n    this.updateLayers(); // Add labels if provided\n\n    if (this.props.baseMap.labelsSrc) {\n      map.createPane(\"labels\");\n      map.getPane(\"labels\").style.zIndex = 600;\n      map.getPane(\"labels\").style.pointerEvents = \"none\";\n      L.tileLayer(this.props.baseMap.labelsSrc, {\n        pane: \"labels\"\n      }).addTo(map);\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    // check if the datasets have changed\n    if (this.props.datasets !== prevProps.datasets) {\n      this.updateLayers();\n    }\n  } // this function contains the html code that will be rendered\n\n\n  render() {\n    return /*#__PURE__*/React.createElement(Container, {\n      fluid: true,\n      className: \"p-0\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 58,\n        columnNumber: 7\n      }\n    }, this.isDataSelected() && /*#__PURE__*/React.createElement(Legend, {\n      datasets: this.props.datasets,\n      selectedDatasets: this.props.selectedDatasets,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 60,\n        columnNumber: 11\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      id: \"map\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 65,\n        columnNumber: 9\n      }\n    }));\n  } // function to update all selected layers\n\n\n}\n\nexport default MainMap;\n\nfunction addShapefile(dataset, chartIsLinked) {\n  shp(require(\"../data/shapefiles/\" + dataset.src)).then(function (geojson) {\n    let newLayer = L.geoJSON(geojson, {\n      style: dataset.style ? function (feature) {\n        return dataset.style(feature.properties[dataset.styleProperty]);\n      } : {},\n      // add point styling\n      pointToLayer: function (feature, latlng) {\n        if (dataset.icon) {\n          // create icon if there is one specified\n          var myIcon = L.icon({\n            iconUrl: require(\"../static/icons/\" + dataset.icon),\n            iconSize: [35, 35],\n            iconAnchor: [16, 37],\n            popupAnchor: [0, -28],\n            tooltipAnchor: [0, -28]\n          });\n          return L.marker(latlng, {\n            icon: myIcon\n          });\n        } else {\n          return L.marker(latlng);\n        }\n      },\n      onEachFeature: function (feature, layer) {\n        // if we want to bind the map to a chart\n        if (chartIsLinked && dataset.chartProperties) {\n          //bind function to click\n          layer.on(\"click\", function (e) {\n            let columns = [[\"x-label\", \"Example x \"]];\n\n            for (let i = 0; i < dataset.chartProperties.length; i++) {\n              columns.push([dataset.namesOfProperties[i], feature.properties[dataset.chartProperties[i]]]);\n            }\n\n            updateChart(columns);\n            newLayer.setStyle(function (feature) {\n              return dataset.style(feature.properties[dataset.styleProperty]);\n            }); //resets layer colors\n\n            layer.setStyle({\n              fillOpacity: 0.7,\n              fillColor: \"#000000\"\n            }); //highlights selected.\n          });\n        } // if we want to add a tooltip\n\n\n        if (dataset.tooltip) {\n          layer.bindTooltip(dataset.tooltip(feature));\n        } // if we want to add a popup on click\n\n\n        if (dataset.popup) {\n          layer.bindPopup(dataset.popup(feature));\n        }\n      }\n    });\n    newLayer.addTo(layers);\n  });\n}\n\nfunction addRaster(dataset) {\n  let style = dataset.style ? dataset.style : d => {\n    return \"#ffffff\";\n  };\n  fetch(require(\"../data/rasters/\" + dataset.src)).then(response => response.arrayBuffer()).then(arrayBuffer => {\n    parse_georaster(arrayBuffer).then(georaster => {\n      var layer = new GeoRasterLayer({\n        georaster: georaster,\n        opacity: 0.7,\n        pixelValuesToColorFn: values => style(values[0]),\n        resolution: 64 // optional parameter for adjusting display resolution\n\n      });\n      layer.addTo(layers);\n    });\n  });\n}\n\nfunction addTiles(dataset) {\n  L.tileLayer(dataset.src, {\n    attribution: \"\"\n  }).addTo(layers);\n}","map":{"version":3,"sources":["/Users/charlotteweil1/Projets/Viz/gobiTraining/src/components/Map.js"],"names":["React","L","shp","Container","Legend","parse_georaster","require","GeoRasterLayer","map","layers","updateChart","MainMap","Component","constructor","props","updateLayers","chartIsLinked","clearLayers","selectedDatasets","forEach","id","dataset","datasets","type","addShapefile","addTiles","addRaster","isDataSelected","length","state","componentDidMount","center","baseMap","zoom","tileLayer","src","attribution","console","log","layerGroup","addTo","labelsSrc","createPane","getPane","style","zIndex","pointerEvents","pane","componentDidUpdate","prevProps","render","then","geojson","newLayer","geoJSON","feature","properties","styleProperty","pointToLayer","latlng","icon","myIcon","iconUrl","iconSize","iconAnchor","popupAnchor","tooltipAnchor","marker","onEachFeature","layer","chartProperties","on","e","columns","i","push","namesOfProperties","setStyle","fillOpacity","fillColor","tooltip","bindTooltip","popup","bindPopup","d","fetch","response","arrayBuffer","georaster","opacity","pixelValuesToColorFn","values","resolution"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport L from \"leaflet\";\nimport shp from \"shpjs\";\nimport Container from \"react-bootstrap/Container\";\n\nimport Legend from \"./Legend\";\n\nconst parse_georaster = require(\"georaster\");\nconst GeoRasterLayer = require(\"georaster-layer-for-leaflet\");\n\n// variables to hold the main map and all the layers displayed\nlet map;\nlet layers;\nlet updateChart;\n\nclass MainMap extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {};\n    updateChart = props.updateChart;\n  }\n\n  // initialize the map\n  componentDidMount() {\n    // create base map\n    map = L.map(\"map\", {\n      center: this.props.baseMap.center,\n      zoom: this.props.baseMap.zoom,\n      layers: [\n        L.tileLayer(this.props.baseMap.src, {\n          attribution: this.props.baseMap.attribution,\n        }),\n      ],\n    });\n    console.log(map);\n    layers = L.layerGroup().addTo(map);\n    this.updateLayers();\n\n    // Add labels if provided\n    if (this.props.baseMap.labelsSrc) {\n      map.createPane(\"labels\");\n      map.getPane(\"labels\").style.zIndex = 600;\n      map.getPane(\"labels\").style.pointerEvents = \"none\";\n      L.tileLayer(this.props.baseMap.labelsSrc, { pane: \"labels\" }).addTo(map);\n    }\n  }\n\n  componentDidUpdate(prevProps) {\n    // check if the datasets have changed\n    if (this.props.datasets !== prevProps.datasets) {\n      this.updateLayers();\n    }\n  }\n\n  // this function contains the html code that will be rendered\n  render() {\n    return (\n      <Container fluid={true} className=\"p-0\">\n        {this.isDataSelected() && (\n          <Legend\n            datasets={this.props.datasets}\n            selectedDatasets={this.props.selectedDatasets}\n          />\n        )}\n        <div id=\"map\"></div>\n      </Container>\n    );\n  }\n\n  // function to update all selected layers\n  updateLayers = () => {\n    this.props.chartIsLinked && updateChart([]);\n    layers.clearLayers();\n    this.props.selectedDatasets.forEach((id) => {\n      let dataset = this.props.datasets[id];\n\n      switch (dataset.type) {\n        case \"shapefile\":\n          addShapefile(dataset, this.props.chartIsLinked);\n          break;\n\n        case \"tiles\":\n          addTiles(dataset);\n          break;\n\n        case \"raster\":\n          addRaster(dataset);\n          break;\n\n        default:\n      }\n    });\n  };\n\n  isDataSelected = () => {\n    return this.props.selectedDatasets.length > 0;\n  };\n}\n\nexport default MainMap;\n\nfunction addShapefile(dataset, chartIsLinked) {\n  shp(require(\"../data/shapefiles/\" + dataset.src)).then(function (geojson) {\n    let newLayer = L.geoJSON(geojson, {\n      style: dataset.style\n        ? function (feature) {\n            return dataset.style(feature.properties[dataset.styleProperty]);\n          }\n        : {},\n\n      // add point styling\n      pointToLayer: function (feature, latlng) {\n        if (dataset.icon) {\n          // create icon if there is one specified\n          var myIcon = L.icon({\n            iconUrl: require(\"../static/icons/\" + dataset.icon),\n            iconSize: [35, 35],\n            iconAnchor: [16, 37],\n            popupAnchor: [0, -28],\n            tooltipAnchor: [0, -28],\n          });\n          return L.marker(latlng, { icon: myIcon });\n        } else {\n          return L.marker(latlng);\n        }\n      },\n\n      onEachFeature: function (feature, layer) {\n        // if we want to bind the map to a chart\n        if (chartIsLinked && dataset.chartProperties) {\n          //bind function to click\n          layer.on(\"click\", function (e) {\n            let columns = [[\"x-label\", \"Example x \"]];\n\n            for (let i = 0; i < dataset.chartProperties.length; i++) {\n              columns.push([\n                dataset.namesOfProperties[i],\n                feature.properties[dataset.chartProperties[i]],\n              ]);\n            }\n            updateChart(columns);\n\n            newLayer.setStyle(function (feature) {\n              return dataset.style(feature.properties[dataset.styleProperty]);\n            }); //resets layer colors\n            layer.setStyle({ fillOpacity: 0.7, fillColor: \"#000000\" }); //highlights selected.\n          });\n        }\n        // if we want to add a tooltip\n        if (dataset.tooltip) {\n          layer.bindTooltip(dataset.tooltip(feature));\n        }\n\n        // if we want to add a popup on click\n        if (dataset.popup) {\n          layer.bindPopup(dataset.popup(feature));\n        }\n      },\n    });\n    newLayer.addTo(layers);\n  });\n}\n\nfunction addRaster(dataset) {\n  let style = dataset.style\n    ? dataset.style\n    : (d) => {\n        return \"#ffffff\";\n      };\n  fetch(require(\"../data/rasters/\" + dataset.src))\n    .then((response) => response.arrayBuffer())\n    .then((arrayBuffer) => {\n      parse_georaster(arrayBuffer).then((georaster) => {\n        var layer = new GeoRasterLayer({\n          georaster: georaster,\n          opacity: 0.7,\n          pixelValuesToColorFn: (values) => style(values[0]),\n          resolution: 64, // optional parameter for adjusting display resolution\n        });\n        layer.addTo(layers);\n      });\n    });\n}\n\nfunction addTiles(dataset) {\n  L.tileLayer(dataset.src, {\n    attribution: \"\",\n  }).addTo(layers);\n}\n"]},"metadata":{},"sourceType":"module"}