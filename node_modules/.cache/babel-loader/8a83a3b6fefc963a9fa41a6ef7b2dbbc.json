{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n/* global L, proj4 */\n\n\nvar _require = require('./utils/utm.js'),\n    isUTM = _require.isUTM,\n    getProj4String = _require.getProj4String;\n\nvar chroma = require('chroma-js');\n\nvar EPSG4326 = 4326;\nvar PROJ4_SUPPORTED_PROJECTIONS = new Set([3857, 4269]);\nvar GeoRasterLayer = L.GridLayer.extend({\n  initialize: function initialize(options) {\n    var _this = this;\n\n    try {\n      if (options.georasters) {\n        this.georasters = options.georasters;\n      } else if (options.georaster) {\n        this.georasters = [options.georaster];\n      } else {\n        throw new Error('You must initialize a GeoRasterLayer with a georaster or georasters value');\n      }\n      /*\n          Unpacking values for use later.\n          We do this in order to increase speed.\n      */\n\n\n      var keys = ['height', 'width', 'noDataValue', 'palette', 'pixelHeight', 'pixelWidth', 'projection', 'sourceType', 'xmin', 'xmax', 'ymin', 'ymax'];\n\n      if (this.georasters.length > 1) {\n        keys.forEach(function (key) {\n          if (_this.same(_this.georasters, key)) {\n            _this[key] = _this.georasters[0][key];\n          } else {\n            throw new Error('all GeoRasters must have the same ' + key);\n          }\n        });\n      } else if (this.georasters.length === 1) {\n        keys.forEach(function (key) {\n          _this[key] = _this.georasters[0][key];\n        });\n      }\n\n      if (this.sourceType === 'url') {\n        if (!options.updateWhenIdle) options.updateWhenIdle = false;\n        if (!options.updateWhenZooming) options.updateWhenZooming = true;\n        if (!options.keepBuffer) options.keepBuffer = 16;\n      }\n\n      if (!options.debugLevel) options.debugLevel = 1;\n      if (!options.keepBuffer) options.keepBuffer = 25;\n      if (!options.resolution) options.resolution = Math.pow(2, 5);\n      if (options.updateWhenZooming === undefined) options.updateWhenZooming = false;\n      this.debugLevel = options.debugLevel;\n      if (this.debugLevel >= 1) console.log('georaster:', options);\n\n      if (this.georasters.every(function (georaster) {\n        return _typeof(georaster.values) === 'object';\n      })) {\n        this.rasters = this.georasters.reduce(function (result, georaster) {\n          result = result.concat(georaster.values);\n          return result;\n        }, []);\n        if (this.debugLevel > 1) console.log('this.rasters:', this.rasters);\n      }\n\n      this.chroma = chroma;\n      this.scale = chroma.scale();\n      this.initProjector();\n      this.initBounds();\n      options.bounds = this._bounds;\n      L.setOptions(this, options);\n      /*\n          Caching the constant tile size, so we don't recalculate everytime we\n          create a new tile\n      */\n\n      var tileSize = this.getTileSize();\n      this.tileHeight = tileSize.y;\n      this.tileWidth = tileSize.x;\n\n      if (this.georasters.length > 1 && !options.pixelValuesToColorFn) {\n        throw 'you must pass in a pixelValuesToColorFn if you are combining rasters';\n      }\n\n      if (this.georasters.length === 1 && this.georasters[0].sourceType === 'url' && this.georasters[0].numberOfRasters === 1 && !options.pixelValuesToColorFn) {\n        // For COG, we can't determine a data min max for color scaling,\n        // so pixelValuesToColorFn is required.\n        throw 'pixelValuesToColorFn is a required option for single-band rasters initialized via URL';\n      }\n    } catch (error) {\n      console.error('ERROR initializing GeoTIFFLayer', error);\n    }\n  },\n  getRasters: function getRasters(options) {\n    var _this2 = this;\n\n    var tileNwPoint = options.tileNwPoint,\n        heightOfSampleInScreenPixels = options.heightOfSampleInScreenPixels,\n        widthOfSampleInScreenPixels = options.widthOfSampleInScreenPixels,\n        coords = options.coords,\n        numberOfSamplesAcross = options.numberOfSamplesAcross,\n        numberOfSamplesDown = options.numberOfSamplesDown,\n        ymax = options.ymax,\n        xmin = options.xmin;\n    if (this.debugLevel >= 1) console.log('starting getRasters with options:', options); // called if georaster was constructed from URL and we need to get\n    // data separately for each tile\n    // aka 'COG mode'\n\n    /*\n      This function takes in coordinates in the rendered image tile and\n      returns the y and x values in the original raster\n    */\n\n    var rasterCoordsForTileCoords = function rasterCoordsForTileCoords(h, w) {\n      var xCenterInMapPixels = tileNwPoint.x + (w + 0.5) * widthOfSampleInScreenPixels;\n      var yCenterInMapPixels = tileNwPoint.y + (h + 0.5) * heightOfSampleInScreenPixels;\n      var mapPoint = L.point(xCenterInMapPixels, yCenterInMapPixels);\n      if (_this2.debugLevel >= 1) console.log('mapPoint:', mapPoint);\n\n      var _map$unproject = _this2._map.unproject(mapPoint, coords.z),\n          lat = _map$unproject.lat,\n          lng = _map$unproject.lng;\n\n      if (_this2.projection === EPSG4326) {\n        return {\n          y: Math.floor((ymax - lat) / _this2.pixelHeight),\n          x: Math.floor((lng - xmin) / _this2.pixelWidth)\n        };\n      } else if (_this2.projector) {\n        /* source raster doesn't use latitude and longitude,\n           so need to reproject point from lat/long to projection of raster\n        */\n        var _projector$inverse = _this2.projector.inverse([lng, lat]),\n            _projector$inverse2 = _slicedToArray(_projector$inverse, 2),\n            x = _projector$inverse2[0],\n            y = _projector$inverse2[1];\n\n        if (x === Infinity || y === Infinity) {\n          if (_this2.debugLevel >= 1) console.error('projector converted', [lng, lat], 'to', [x, y]);\n        }\n\n        return {\n          y: Math.floor((ymax - y) / _this2.pixelHeight),\n          x: Math.floor((x - xmin) / _this2.pixelWidth)\n        };\n      }\n    }; // careful not to flip min_y/max_y here\n\n\n    var topLeft = rasterCoordsForTileCoords(0, 0);\n    var bottomRight = rasterCoordsForTileCoords(numberOfSamplesDown - 1, numberOfSamplesAcross - 1);\n    var getValuesOptions = {\n      bottom: bottomRight.y,\n      height: numberOfSamplesDown,\n      left: topLeft.x,\n      right: bottomRight.x,\n      top: topLeft.y,\n      width: numberOfSamplesAcross\n    };\n\n    if (!Object.values(getValuesOptions).every(isFinite)) {\n      console.error('getRasters failed because not all values are finite:', getValuesOptions);\n    } else {\n      return Promise.all(this.georasters.map(function (georaster) {\n        return georaster.getValues(getValuesOptions);\n      })).then(function (valuesByGeoRaster) {\n        return valuesByGeoRaster.reduce(function (result, values) {\n          result = result.concat(values);\n          return result;\n        }, []);\n      });\n    }\n  },\n  createTile: function createTile(coords, done) {\n    var _this3 = this;\n\n    var error = void 0; // Unpacking values for increased speed\n\n    var pixelHeight = this.pixelHeight,\n        pixelWidth = this.pixelWidth,\n        rasters = this.rasters,\n        xmin = this.xmin,\n        ymax = this.ymax;\n    var rasterHeight = this.height;\n    var rasterWidth = this.width; // these values are used so we don't try to sample outside of the raster\n\n    var minLng = this.minLng,\n        maxLng = this.maxLng,\n        maxLat = this.maxLat,\n        minLat = this.minLat;\n    /* This tile is the square piece of the Leaflet map that we draw on */\n\n    var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n    tile.height = this.tileHeight;\n    tile.width = this.tileWidth;\n    var context = tile.getContext('2d');\n\n    var bounds = this._tileCoordsToBounds(coords);\n\n    var minLngOfTile = bounds.getWest();\n    var maxLngOfTile = bounds.getEast();\n    var minLatOfTile = bounds.getSouth();\n    var maxLatOfTile = bounds.getNorth();\n    var rasterPixelsAcross = void 0,\n        rasterPixelsDown = void 0;\n\n    if (this.projection === EPSG4326) {\n      // width of the Leaflet tile in number of pixels from original raster\n      rasterPixelsAcross = Math.ceil((maxLngOfTile - minLngOfTile) / pixelWidth);\n      rasterPixelsDown = Math.ceil((maxLatOfTile - minLatOfTile) / pixelHeight);\n    } else if (this.projector) {\n      // convert extent of Leaflet tile to projection of the georaster\n      var topLeft = this.projector.inverse({\n        x: minLngOfTile,\n        y: maxLatOfTile\n      });\n      var topRight = this.projector.inverse({\n        x: maxLngOfTile,\n        y: maxLatOfTile\n      });\n      var bottomLeft = this.projector.inverse({\n        x: minLngOfTile,\n        y: minLatOfTile\n      });\n      var bottomRight = this.projector.inverse({\n        x: maxLngOfTile,\n        y: minLatOfTile\n      });\n      rasterPixelsAcross = Math.ceil(Math.max(topRight.x - topLeft.x, bottomRight.x - bottomLeft.x) / pixelWidth);\n      rasterPixelsDown = Math.ceil(Math.max(topLeft.y - bottomLeft.y, topRight.y - bottomRight.y) / pixelHeight);\n    }\n\n    var resolution = this.options.resolution; // prevent sampling more times than number of pixels to display\n\n    var numberOfSamplesAcross = Math.min(resolution, rasterPixelsAcross);\n    var numberOfSamplesDown = Math.min(resolution, rasterPixelsDown); // set how large to display each sample in screen pixels\n\n    var heightOfSampleInScreenPixels = this.tileHeight / numberOfSamplesDown;\n    var heightOfSampleInScreenPixelsInt = Math.ceil(heightOfSampleInScreenPixels);\n    var widthOfSampleInScreenPixels = this.tileWidth / numberOfSamplesAcross;\n    var widthOfSampleInScreenPixelsInt = Math.ceil(widthOfSampleInScreenPixels);\n    var map = this._map;\n    var tileSize = this.getTileSize(); // this converts tile coordinates (how many tiles down and right)\n    // to pixels from left and top of tile pane\n\n    var tileNwPoint = coords.scaleBy(tileSize); // render asynchronously so tiles show up as they finish instead of all at once (which blocks the UI)\n\n    setTimeout(async function () {\n      var tileRasters = void 0;\n\n      if (!rasters) {\n        tileRasters = await _this3.getRasters({\n          tileNwPoint: tileNwPoint,\n          heightOfSampleInScreenPixels: heightOfSampleInScreenPixels,\n          widthOfSampleInScreenPixels: widthOfSampleInScreenPixels,\n          coords: coords,\n          pixelHeight: pixelHeight,\n          pixelWidth: pixelWidth,\n          numberOfSamplesAcross: numberOfSamplesAcross,\n          numberOfSamplesDown: numberOfSamplesDown,\n          ymax: ymax,\n          xmin: xmin\n        });\n      }\n\n      var _loop = function _loop(h) {\n        var yCenterInMapPixels = tileNwPoint.y + (h + 0.5) * heightOfSampleInScreenPixels;\n        var latWestPoint = L.point(tileNwPoint.x, yCenterInMapPixels);\n\n        var _map$unproject2 = map.unproject(latWestPoint, coords.z),\n            lat = _map$unproject2.lat;\n\n        if (lat > minLat && lat < maxLat) {\n          var _ret2 = function () {\n            var yInTilePixels = Math.round(h * heightOfSampleInScreenPixels);\n            var yInRasterPixels = _this3.projection === EPSG4326 ? Math.floor((maxLat - lat) / pixelHeight) : null;\n\n            var _loop2 = function _loop2(w) {\n              var latLngPoint = L.point(tileNwPoint.x + (w + 0.5) * widthOfSampleInScreenPixels, yCenterInMapPixels);\n\n              var _map$unproject3 = map.unproject(latLngPoint, coords.z),\n                  lng = _map$unproject3.lng;\n\n              if (lng > minLng && lng < maxLng) {\n                var xInRasterPixels = void 0;\n\n                if (_this3.projection === EPSG4326) {\n                  xInRasterPixels = Math.floor((lng - minLng) / pixelWidth);\n                } else if (_this3.projector) {\n                  var inverted = _this3.projector.inverse({\n                    x: lng,\n                    y: lat\n                  });\n\n                  var yInSrc = inverted.y;\n                  yInRasterPixels = Math.floor((ymax - yInSrc) / pixelHeight);\n                  if (yInRasterPixels < 0 || yInRasterPixels >= rasterHeight) return 'continue';\n                  var xInSrc = inverted.x;\n                  xInRasterPixels = Math.floor((xInSrc - xmin) / pixelWidth);\n                  if (xInRasterPixels < 0 || xInRasterPixels >= rasterWidth) return 'continue';\n                }\n\n                var values = null;\n\n                if (tileRasters) {\n                  // get value from array specific to this tile\n                  values = tileRasters.map(function (band) {\n                    return band[h][w];\n                  });\n                } else if (rasters) {\n                  // get value from array with data for entire raster\n                  values = rasters.map(function (band) {\n                    return band[yInRasterPixels][xInRasterPixels];\n                  });\n                } else {\n                  done('no rasters are available for, so skipping value generation');\n                  return {\n                    v: {\n                      v: {\n                        v: void 0\n                      }\n                    }\n                  };\n                } // x-axis coordinate of the starting point of the rectangle representing the raster pixel\n\n\n                var x = Math.round(w * widthOfSampleInScreenPixels); // y-axis coordinate of the starting point of the rectangle representing the raster pixel\n\n                var y = yInTilePixels; // how many real screen pixels does a pixel of the sampled raster take up\n\n                var width = widthOfSampleInScreenPixelsInt;\n                var height = heightOfSampleInScreenPixelsInt;\n\n                if (_this3.options.customDrawFunction) {\n                  _this3.options.customDrawFunction({\n                    values: values,\n                    context: context,\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                  });\n                } else {\n                  var color = _this3.getColor(values);\n\n                  if (color) {\n                    context.fillStyle = color;\n                    context.fillRect(x, y, width, height);\n                  }\n                }\n              }\n            };\n\n            for (var w = 0; w < numberOfSamplesAcross; w++) {\n              var _ret3 = _loop2(w);\n\n              switch (_ret3) {\n                case 'continue':\n                  continue;\n\n                default:\n                  if ((typeof _ret3 === 'undefined' ? 'undefined' : _typeof(_ret3)) === \"object\") return _ret3.v;\n              }\n            }\n          }();\n\n          if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n        }\n      };\n\n      for (var h = 0; h < numberOfSamplesDown; h++) {\n        var _ret = _loop(h);\n\n        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n      }\n\n      done(error, tile);\n    }, 0); // return the tile so it can be rendered on screen\n\n    return tile;\n  },\n  // method from https://github.com/Leaflet/Leaflet/blob/bb1d94ac7f2716852213dd11563d89855f8d6bb1/src/layer/ImageOverlay.js\n  getBounds: function getBounds() {\n    return this._bounds;\n  },\n  _isValidTile: function _isValidTile(coords) {\n    var crs = this._map.options.crs;\n\n    if (!crs.infinite) {\n      // don't load tile if it's out of bounds and not wrapped\n      var bounds = this._globalTileRange;\n\n      if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {\n        return false;\n      }\n    }\n\n    if (!this.options.bounds) {\n      return true;\n    }\n\n    var x = coords.x,\n        y = coords.y,\n        z = coords.z;\n    var layerBounds = L.latLngBounds(this.options.bounds); // check given tile coordinates\n\n    if (layerBounds.overlaps(this._tileCoordsToBounds(coords))) return true; // width of the globe in tiles at the given zoom level\n\n    var width = Math.pow(2, z); // check one world to the left\n\n    var leftCoords = L.point(x - width, y);\n    leftCoords.z = z;\n    if (layerBounds.overlaps(this._tileCoordsToBounds(leftCoords))) return true; // check one world to the right\n\n    var rightCoords = L.point(x + width, y);\n    rightCoords.z = z;\n    if (layerBounds.overlaps(this._tileCoordsToBounds(rightCoords))) return true;\n    return false;\n  },\n  getColor: function getColor(values) {\n    var _this4 = this;\n\n    if (this.options.pixelValuesToColorFn) {\n      return this.options.pixelValuesToColorFn(values);\n    } else {\n      var numberOfValues = values.length;\n      var haveDataForAllBands = values.every(function (value) {\n        return value !== undefined && value !== _this4.noDataValue;\n      });\n\n      if (haveDataForAllBands) {\n        if (numberOfValues == 1) {\n          var _georasters$ = this.georasters[0],\n              mins = _georasters$.mins,\n              ranges = _georasters$.ranges;\n          var value = values[0];\n\n          if (this.palette) {\n            var _palette$value = _slicedToArray(this.palette[value], 4),\n                r = _palette$value[0],\n                g = _palette$value[1],\n                b = _palette$value[2],\n                a = _palette$value[3];\n\n            return 'rgba(' + r + ',' + g + ',' + b + ',' + a / 255 + ')';\n          } else {\n            return this.scale((values[0] - mins[0]) / ranges[0]).hex();\n          }\n        } else if (numberOfValues === 2) {\n          return 'rgb(' + values[0] + ',' + values[1] + ',0)';\n        } else if (numberOfValues === 3) {\n          return 'rgb(' + values[0] + ',' + values[1] + ',' + values[2] + ')';\n        } else if (numberOfValues === 4) {\n          return 'rgba(' + values[0] + ',' + values[1] + ',' + values[2] + ',' + values[3] / 255 + ')';\n        }\n      }\n    }\n  },\n  isSupportedProjection: function isSupportedProjection(projection) {\n    return isUTM(projection) || PROJ4_SUPPORTED_PROJECTIONS.has(projection);\n  },\n  getProjectionString: function getProjectionString(projection) {\n    if (isUTM(projection)) {\n      return getProj4String(projection);\n    }\n\n    return 'EPSG:' + projection;\n  },\n  initBounds: function initBounds(georaster) {\n    var debugLevel = this.debugLevel,\n        projection = this.projection,\n        xmin = this.xmin,\n        xmax = this.xmax,\n        ymin = this.ymin,\n        ymax = this.ymax;\n    if (debugLevel >= 1) console.log('this.projection is', projection);\n\n    if (projection === EPSG4326) {\n      if (debugLevel >= 1) console.log('georaster projection is in ' + EPSG4326);\n      var minLatWest = L.latLng(ymin, xmin);\n      var maxLatEast = L.latLng(ymax, xmax);\n      this._bounds = L.latLngBounds(minLatWest, maxLatEast);\n    } else if (this.isSupportedProjection(projection)) {\n      if (debugLevel >= 1) console.log('projection is UTM or supported by proj4');\n      var bottomLeft = this.projector.forward({\n        x: xmin,\n        y: ymin\n      });\n\n      var _minLatWest = L.latLng(bottomLeft.y, bottomLeft.x);\n\n      var topRight = this.projector.forward({\n        x: xmax,\n        y: ymax\n      });\n\n      var _maxLatEast = L.latLng(topRight.y, topRight.x);\n\n      this._bounds = L.latLngBounds(_minLatWest, _maxLatEast);\n    } else {\n      throw 'georaster-layer-for-leaflet does not support rasters with the projection ' + projection;\n    } // these values are used so we don't try to sample outside of the raster\n\n\n    this.minLng = this._bounds.getWest();\n    this.maxLng = this._bounds.getEast();\n    this.maxLat = this._bounds.getNorth();\n    this.minLat = this._bounds.getSouth();\n  },\n  initProjector: function initProjector() {\n    if (this.isSupportedProjection(this.projection)) {\n      if (!proj4) {\n        throw 'proj4 must be found in the global scope in order to load a raster that uses a UTM projection';\n      }\n\n      this.projector = proj4(this.getProjectionString(this.projection), 'EPSG:' + EPSG4326);\n      if (this.debugLevel >= 1) console.log('projector set');\n    }\n  },\n  same: function same(array, key) {\n    return new Set(array.map(function (item) {\n      return item[key];\n    })).size === 1;\n  }\n});\n\nif (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n  module.exports = GeoRasterLayer;\n}\n\nif (typeof window !== 'undefined') {\n  window['GeoRasterLayer'] = GeoRasterLayer;\n} else if (typeof self !== 'undefined') {\n  self['GeoRasterLayer'] = GeoRasterLayer; // jshint ignore:line\n}","map":{"version":3,"sources":["/Users/charlotteweil1/Projets/Viz/gobiTraining/node_modules/georaster-layer-for-leaflet/georaster-layer-for-leaflet.bundle.js"],"names":["_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","length","err","Array","isArray","Object","TypeError","_typeof","obj","constructor","prototype","_require","require","isUTM","getProj4String","chroma","EPSG4326","PROJ4_SUPPORTED_PROJECTIONS","Set","GeoRasterLayer","L","GridLayer","extend","initialize","options","_this","georasters","georaster","Error","keys","forEach","key","same","sourceType","updateWhenIdle","updateWhenZooming","keepBuffer","debugLevel","resolution","Math","pow","console","log","every","values","rasters","reduce","result","concat","scale","initProjector","initBounds","bounds","_bounds","setOptions","tileSize","getTileSize","tileHeight","y","tileWidth","x","pixelValuesToColorFn","numberOfRasters","error","getRasters","_this2","tileNwPoint","heightOfSampleInScreenPixels","widthOfSampleInScreenPixels","coords","numberOfSamplesAcross","numberOfSamplesDown","ymax","xmin","rasterCoordsForTileCoords","h","w","xCenterInMapPixels","yCenterInMapPixels","mapPoint","point","_map$unproject","_map","unproject","z","lat","lng","projection","floor","pixelHeight","pixelWidth","projector","_projector$inverse","inverse","_projector$inverse2","Infinity","topLeft","bottomRight","getValuesOptions","bottom","height","left","right","top","width","isFinite","Promise","all","map","getValues","then","valuesByGeoRaster","createTile","_this3","rasterHeight","rasterWidth","minLng","maxLng","maxLat","minLat","tile","DomUtil","create","context","getContext","_tileCoordsToBounds","minLngOfTile","getWest","maxLngOfTile","getEast","minLatOfTile","getSouth","maxLatOfTile","getNorth","rasterPixelsAcross","rasterPixelsDown","ceil","topRight","bottomLeft","max","min","heightOfSampleInScreenPixelsInt","widthOfSampleInScreenPixelsInt","scaleBy","setTimeout","tileRasters","_loop","latWestPoint","_map$unproject2","_ret2","yInTilePixels","round","yInRasterPixels","_loop2","latLngPoint","_map$unproject3","xInRasterPixels","inverted","yInSrc","xInSrc","band","v","customDrawFunction","color","getColor","fillStyle","fillRect","_ret3","_ret","getBounds","_isValidTile","crs","infinite","_globalTileRange","wrapLng","wrapLat","layerBounds","latLngBounds","overlaps","leftCoords","rightCoords","_this4","numberOfValues","haveDataForAllBands","noDataValue","_georasters$","mins","ranges","palette","_palette$value","r","g","b","a","hex","isSupportedProjection","has","getProjectionString","xmax","ymin","minLatWest","latLng","maxLatEast","forward","_minLatWest","_maxLatEast","proj4","array","item","size","module","exports","window","self"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/* global L, proj4 */\nvar _require = require('./utils/utm.js'),\n    isUTM = _require.isUTM,\n    getProj4String = _require.getProj4String;\n\nvar chroma = require('chroma-js');\n\nvar EPSG4326 = 4326;\nvar PROJ4_SUPPORTED_PROJECTIONS = new Set([3857, 4269]);\nvar GeoRasterLayer = L.GridLayer.extend({\n\n  initialize: function initialize(options) {\n    var _this = this;\n\n    try {\n\n      if (options.georasters) {\n        this.georasters = options.georasters;\n      } else if (options.georaster) {\n        this.georasters = [options.georaster];\n      } else {\n        throw new Error('You must initialize a GeoRasterLayer with a georaster or georasters value');\n      }\n\n      /*\n          Unpacking values for use later.\n          We do this in order to increase speed.\n      */\n      var keys = ['height', 'width', 'noDataValue', 'palette', 'pixelHeight', 'pixelWidth', 'projection', 'sourceType', 'xmin', 'xmax', 'ymin', 'ymax'];\n      if (this.georasters.length > 1) {\n        keys.forEach(function (key) {\n          if (_this.same(_this.georasters, key)) {\n            _this[key] = _this.georasters[0][key];\n          } else {\n            throw new Error('all GeoRasters must have the same ' + key);\n          }\n        });\n      } else if (this.georasters.length === 1) {\n        keys.forEach(function (key) {\n          _this[key] = _this.georasters[0][key];\n        });\n      }\n\n      if (this.sourceType === 'url') {\n        if (!options.updateWhenIdle) options.updateWhenIdle = false;\n        if (!options.updateWhenZooming) options.updateWhenZooming = true;\n        if (!options.keepBuffer) options.keepBuffer = 16;\n      }\n\n      if (!options.debugLevel) options.debugLevel = 1;\n      if (!options.keepBuffer) options.keepBuffer = 25;\n      if (!options.resolution) options.resolution = Math.pow(2, 5);\n      if (options.updateWhenZooming === undefined) options.updateWhenZooming = false;\n\n      this.debugLevel = options.debugLevel;\n      if (this.debugLevel >= 1) console.log('georaster:', options);\n\n      if (this.georasters.every(function (georaster) {\n        return _typeof(georaster.values) === 'object';\n      })) {\n        this.rasters = this.georasters.reduce(function (result, georaster) {\n          result = result.concat(georaster.values);\n          return result;\n        }, []);\n        if (this.debugLevel > 1) console.log('this.rasters:', this.rasters);\n      }\n\n      this.chroma = chroma;\n      this.scale = chroma.scale();\n\n      this.initProjector();\n      this.initBounds();\n      options.bounds = this._bounds;\n      L.setOptions(this, options);\n\n      /*\n          Caching the constant tile size, so we don't recalculate everytime we\n          create a new tile\n      */\n      var tileSize = this.getTileSize();\n      this.tileHeight = tileSize.y;\n      this.tileWidth = tileSize.x;\n\n      if (this.georasters.length > 1 && !options.pixelValuesToColorFn) {\n        throw 'you must pass in a pixelValuesToColorFn if you are combining rasters';\n      }\n\n      if (this.georasters.length === 1 && this.georasters[0].sourceType === 'url' && this.georasters[0].numberOfRasters === 1 && !options.pixelValuesToColorFn) {\n        // For COG, we can't determine a data min max for color scaling,\n        // so pixelValuesToColorFn is required.\n        throw 'pixelValuesToColorFn is a required option for single-band rasters initialized via URL';\n      }\n    } catch (error) {\n      console.error('ERROR initializing GeoTIFFLayer', error);\n    }\n  },\n\n  getRasters: function getRasters(options) {\n    var _this2 = this;\n\n    var tileNwPoint = options.tileNwPoint,\n        heightOfSampleInScreenPixels = options.heightOfSampleInScreenPixels,\n        widthOfSampleInScreenPixels = options.widthOfSampleInScreenPixels,\n        coords = options.coords,\n        numberOfSamplesAcross = options.numberOfSamplesAcross,\n        numberOfSamplesDown = options.numberOfSamplesDown,\n        ymax = options.ymax,\n        xmin = options.xmin;\n\n    if (this.debugLevel >= 1) console.log('starting getRasters with options:', options);\n    // called if georaster was constructed from URL and we need to get\n    // data separately for each tile\n    // aka 'COG mode'\n\n    /*\n      This function takes in coordinates in the rendered image tile and\n      returns the y and x values in the original raster\n    */\n    var rasterCoordsForTileCoords = function rasterCoordsForTileCoords(h, w) {\n\n      var xCenterInMapPixels = tileNwPoint.x + (w + 0.5) * widthOfSampleInScreenPixels;\n      var yCenterInMapPixels = tileNwPoint.y + (h + 0.5) * heightOfSampleInScreenPixels;\n\n      var mapPoint = L.point(xCenterInMapPixels, yCenterInMapPixels);\n      if (_this2.debugLevel >= 1) console.log('mapPoint:', mapPoint);\n\n      var _map$unproject = _this2._map.unproject(mapPoint, coords.z),\n          lat = _map$unproject.lat,\n          lng = _map$unproject.lng;\n\n      if (_this2.projection === EPSG4326) {\n        return {\n          y: Math.floor((ymax - lat) / _this2.pixelHeight),\n          x: Math.floor((lng - xmin) / _this2.pixelWidth)\n        };\n      } else if (_this2.projector) {\n        /* source raster doesn't use latitude and longitude,\n           so need to reproject point from lat/long to projection of raster\n        */\n        var _projector$inverse = _this2.projector.inverse([lng, lat]),\n            _projector$inverse2 = _slicedToArray(_projector$inverse, 2),\n            x = _projector$inverse2[0],\n            y = _projector$inverse2[1];\n\n        if (x === Infinity || y === Infinity) {\n          if (_this2.debugLevel >= 1) console.error('projector converted', [lng, lat], 'to', [x, y]);\n        }\n        return {\n          y: Math.floor((ymax - y) / _this2.pixelHeight),\n          x: Math.floor((x - xmin) / _this2.pixelWidth)\n        };\n      }\n    };\n\n    // careful not to flip min_y/max_y here\n    var topLeft = rasterCoordsForTileCoords(0, 0);\n    var bottomRight = rasterCoordsForTileCoords(numberOfSamplesDown - 1, numberOfSamplesAcross - 1);\n\n    var getValuesOptions = {\n      bottom: bottomRight.y,\n      height: numberOfSamplesDown,\n      left: topLeft.x,\n      right: bottomRight.x,\n      top: topLeft.y,\n      width: numberOfSamplesAcross\n    };\n    if (!Object.values(getValuesOptions).every(isFinite)) {\n      console.error('getRasters failed because not all values are finite:', getValuesOptions);\n    } else {\n      return Promise.all(this.georasters.map(function (georaster) {\n        return georaster.getValues(getValuesOptions);\n      })).then(function (valuesByGeoRaster) {\n        return valuesByGeoRaster.reduce(function (result, values) {\n          result = result.concat(values);\n          return result;\n        }, []);\n      });\n    }\n  },\n\n  createTile: function createTile(coords, done) {\n    var _this3 = this;\n\n    var error = void 0;\n\n    // Unpacking values for increased speed\n    var pixelHeight = this.pixelHeight,\n        pixelWidth = this.pixelWidth,\n        rasters = this.rasters,\n        xmin = this.xmin,\n        ymax = this.ymax;\n\n    var rasterHeight = this.height;\n    var rasterWidth = this.width;\n\n    // these values are used so we don't try to sample outside of the raster\n    var minLng = this.minLng,\n        maxLng = this.maxLng,\n        maxLat = this.maxLat,\n        minLat = this.minLat;\n\n    /* This tile is the square piece of the Leaflet map that we draw on */\n\n    var tile = L.DomUtil.create('canvas', 'leaflet-tile');\n    tile.height = this.tileHeight;\n    tile.width = this.tileWidth;\n    var context = tile.getContext('2d');\n\n    var bounds = this._tileCoordsToBounds(coords);\n\n    var minLngOfTile = bounds.getWest();\n    var maxLngOfTile = bounds.getEast();\n    var minLatOfTile = bounds.getSouth();\n    var maxLatOfTile = bounds.getNorth();\n\n    var rasterPixelsAcross = void 0,\n        rasterPixelsDown = void 0;\n    if (this.projection === EPSG4326) {\n      // width of the Leaflet tile in number of pixels from original raster\n      rasterPixelsAcross = Math.ceil((maxLngOfTile - minLngOfTile) / pixelWidth);\n      rasterPixelsDown = Math.ceil((maxLatOfTile - minLatOfTile) / pixelHeight);\n    } else if (this.projector) {\n\n      // convert extent of Leaflet tile to projection of the georaster\n      var topLeft = this.projector.inverse({ x: minLngOfTile, y: maxLatOfTile });\n      var topRight = this.projector.inverse({ x: maxLngOfTile, y: maxLatOfTile });\n      var bottomLeft = this.projector.inverse({ x: minLngOfTile, y: minLatOfTile });\n      var bottomRight = this.projector.inverse({ x: maxLngOfTile, y: minLatOfTile });\n\n      rasterPixelsAcross = Math.ceil(Math.max(topRight.x - topLeft.x, bottomRight.x - bottomLeft.x) / pixelWidth);\n      rasterPixelsDown = Math.ceil(Math.max(topLeft.y - bottomLeft.y, topRight.y - bottomRight.y) / pixelHeight);\n    }\n\n    var resolution = this.options.resolution;\n\n    // prevent sampling more times than number of pixels to display\n\n    var numberOfSamplesAcross = Math.min(resolution, rasterPixelsAcross);\n    var numberOfSamplesDown = Math.min(resolution, rasterPixelsDown);\n\n    // set how large to display each sample in screen pixels\n    var heightOfSampleInScreenPixels = this.tileHeight / numberOfSamplesDown;\n    var heightOfSampleInScreenPixelsInt = Math.ceil(heightOfSampleInScreenPixels);\n    var widthOfSampleInScreenPixels = this.tileWidth / numberOfSamplesAcross;\n    var widthOfSampleInScreenPixelsInt = Math.ceil(widthOfSampleInScreenPixels);\n\n    var map = this._map;\n    var tileSize = this.getTileSize();\n\n    // this converts tile coordinates (how many tiles down and right)\n    // to pixels from left and top of tile pane\n    var tileNwPoint = coords.scaleBy(tileSize);\n\n    // render asynchronously so tiles show up as they finish instead of all at once (which blocks the UI)\n    setTimeout(async function () {\n      var tileRasters = void 0;\n      if (!rasters) {\n        tileRasters = await _this3.getRasters({\n          tileNwPoint: tileNwPoint, heightOfSampleInScreenPixels: heightOfSampleInScreenPixels,\n          widthOfSampleInScreenPixels: widthOfSampleInScreenPixels, coords: coords, pixelHeight: pixelHeight, pixelWidth: pixelWidth,\n          numberOfSamplesAcross: numberOfSamplesAcross, numberOfSamplesDown: numberOfSamplesDown, ymax: ymax, xmin: xmin });\n      }\n\n      var _loop = function _loop(h) {\n        var yCenterInMapPixels = tileNwPoint.y + (h + 0.5) * heightOfSampleInScreenPixels;\n        var latWestPoint = L.point(tileNwPoint.x, yCenterInMapPixels);\n\n        var _map$unproject2 = map.unproject(latWestPoint, coords.z),\n            lat = _map$unproject2.lat;\n\n        if (lat > minLat && lat < maxLat) {\n          var _ret2 = function () {\n            var yInTilePixels = Math.round(h * heightOfSampleInScreenPixels);\n            var yInRasterPixels = _this3.projection === EPSG4326 ? Math.floor((maxLat - lat) / pixelHeight) : null;\n\n            var _loop2 = function _loop2(w) {\n              var latLngPoint = L.point(tileNwPoint.x + (w + 0.5) * widthOfSampleInScreenPixels, yCenterInMapPixels);\n\n              var _map$unproject3 = map.unproject(latLngPoint, coords.z),\n                  lng = _map$unproject3.lng;\n\n              if (lng > minLng && lng < maxLng) {\n                var xInRasterPixels = void 0;\n                if (_this3.projection === EPSG4326) {\n                  xInRasterPixels = Math.floor((lng - minLng) / pixelWidth);\n                } else if (_this3.projector) {\n                  var inverted = _this3.projector.inverse({ x: lng, y: lat });\n                  var yInSrc = inverted.y;\n                  yInRasterPixels = Math.floor((ymax - yInSrc) / pixelHeight);\n                  if (yInRasterPixels < 0 || yInRasterPixels >= rasterHeight) return 'continue';\n\n                  var xInSrc = inverted.x;\n                  xInRasterPixels = Math.floor((xInSrc - xmin) / pixelWidth);\n                  if (xInRasterPixels < 0 || xInRasterPixels >= rasterWidth) return 'continue';\n                }\n\n                var values = null;\n                if (tileRasters) {\n                  // get value from array specific to this tile\n                  values = tileRasters.map(function (band) {\n                    return band[h][w];\n                  });\n                } else if (rasters) {\n                  // get value from array with data for entire raster\n                  values = rasters.map(function (band) {\n                    return band[yInRasterPixels][xInRasterPixels];\n                  });\n                } else {\n                  done('no rasters are available for, so skipping value generation');\n                  return {\n                    v: {\n                      v: {\n                        v: void 0\n                      }\n                    }\n                  };\n                }\n\n                // x-axis coordinate of the starting point of the rectangle representing the raster pixel\n                var x = Math.round(w * widthOfSampleInScreenPixels);\n\n                // y-axis coordinate of the starting point of the rectangle representing the raster pixel\n                var y = yInTilePixels;\n\n                // how many real screen pixels does a pixel of the sampled raster take up\n                var width = widthOfSampleInScreenPixelsInt;\n                var height = heightOfSampleInScreenPixelsInt;\n\n                if (_this3.options.customDrawFunction) {\n                  _this3.options.customDrawFunction({ values: values, context: context, x: x, y: y, width: width, height: height });\n                } else {\n                  var color = _this3.getColor(values);\n                  if (color) {\n                    context.fillStyle = color;\n                    context.fillRect(x, y, width, height);\n                  }\n                }\n              }\n            };\n\n            for (var w = 0; w < numberOfSamplesAcross; w++) {\n              var _ret3 = _loop2(w);\n\n              switch (_ret3) {\n                case 'continue':\n                  continue;\n\n                default:\n                  if ((typeof _ret3 === 'undefined' ? 'undefined' : _typeof(_ret3)) === \"object\") return _ret3.v;\n              }\n            }\n          }();\n\n          if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n        }\n      };\n\n      for (var h = 0; h < numberOfSamplesDown; h++) {\n        var _ret = _loop(h);\n\n        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n      }\n\n      done(error, tile);\n    }, 0);\n\n    // return the tile so it can be rendered on screen\n    return tile;\n  },\n\n  // method from https://github.com/Leaflet/Leaflet/blob/bb1d94ac7f2716852213dd11563d89855f8d6bb1/src/layer/ImageOverlay.js\n  getBounds: function getBounds() {\n    return this._bounds;\n  },\n\n  _isValidTile: function _isValidTile(coords) {\n    var crs = this._map.options.crs;\n\n    if (!crs.infinite) {\n      // don't load tile if it's out of bounds and not wrapped\n      var bounds = this._globalTileRange;\n      if (!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x) || !crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y)) {\n        return false;\n      }\n    }\n\n    if (!this.options.bounds) {\n      return true;\n    }\n\n    var x = coords.x,\n        y = coords.y,\n        z = coords.z;\n\n\n    var layerBounds = L.latLngBounds(this.options.bounds);\n\n    // check given tile coordinates\n    if (layerBounds.overlaps(this._tileCoordsToBounds(coords))) return true;\n\n    // width of the globe in tiles at the given zoom level\n    var width = Math.pow(2, z);\n\n    // check one world to the left\n    var leftCoords = L.point(x - width, y);\n    leftCoords.z = z;\n    if (layerBounds.overlaps(this._tileCoordsToBounds(leftCoords))) return true;\n\n    // check one world to the right\n    var rightCoords = L.point(x + width, y);\n    rightCoords.z = z;\n    if (layerBounds.overlaps(this._tileCoordsToBounds(rightCoords))) return true;\n\n    return false;\n  },\n\n  getColor: function getColor(values) {\n    var _this4 = this;\n\n    if (this.options.pixelValuesToColorFn) {\n      return this.options.pixelValuesToColorFn(values);\n    } else {\n      var numberOfValues = values.length;\n      var haveDataForAllBands = values.every(function (value) {\n        return value !== undefined && value !== _this4.noDataValue;\n      });\n      if (haveDataForAllBands) {\n        if (numberOfValues == 1) {\n          var _georasters$ = this.georasters[0],\n              mins = _georasters$.mins,\n              ranges = _georasters$.ranges;\n\n          var value = values[0];\n          if (this.palette) {\n            var _palette$value = _slicedToArray(this.palette[value], 4),\n                r = _palette$value[0],\n                g = _palette$value[1],\n                b = _palette$value[2],\n                a = _palette$value[3];\n\n            return 'rgba(' + r + ',' + g + ',' + b + ',' + a / 255 + ')';\n          } else {\n            return this.scale((values[0] - mins[0]) / ranges[0]).hex();\n          }\n        } else if (numberOfValues === 2) {\n          return 'rgb(' + values[0] + ',' + values[1] + ',0)';\n        } else if (numberOfValues === 3) {\n          return 'rgb(' + values[0] + ',' + values[1] + ',' + values[2] + ')';\n        } else if (numberOfValues === 4) {\n          return 'rgba(' + values[0] + ',' + values[1] + ',' + values[2] + ',' + values[3] / 255 + ')';\n        }\n      }\n    }\n  },\n\n  isSupportedProjection: function isSupportedProjection(projection) {\n    return isUTM(projection) || PROJ4_SUPPORTED_PROJECTIONS.has(projection);\n  },\n\n  getProjectionString: function getProjectionString(projection) {\n    if (isUTM(projection)) {\n      return getProj4String(projection);\n    }\n    return 'EPSG:' + projection;\n  },\n\n  initBounds: function initBounds(georaster) {\n    var debugLevel = this.debugLevel,\n        projection = this.projection,\n        xmin = this.xmin,\n        xmax = this.xmax,\n        ymin = this.ymin,\n        ymax = this.ymax;\n\n    if (debugLevel >= 1) console.log('this.projection is', projection);\n    if (projection === EPSG4326) {\n      if (debugLevel >= 1) console.log('georaster projection is in ' + EPSG4326);\n      var minLatWest = L.latLng(ymin, xmin);\n      var maxLatEast = L.latLng(ymax, xmax);\n      this._bounds = L.latLngBounds(minLatWest, maxLatEast);\n    } else if (this.isSupportedProjection(projection)) {\n      if (debugLevel >= 1) console.log('projection is UTM or supported by proj4');\n      var bottomLeft = this.projector.forward({ x: xmin, y: ymin });\n      var _minLatWest = L.latLng(bottomLeft.y, bottomLeft.x);\n      var topRight = this.projector.forward({ x: xmax, y: ymax });\n      var _maxLatEast = L.latLng(topRight.y, topRight.x);\n      this._bounds = L.latLngBounds(_minLatWest, _maxLatEast);\n    } else {\n      throw 'georaster-layer-for-leaflet does not support rasters with the projection ' + projection;\n    }\n\n    // these values are used so we don't try to sample outside of the raster\n    this.minLng = this._bounds.getWest();\n    this.maxLng = this._bounds.getEast();\n    this.maxLat = this._bounds.getNorth();\n    this.minLat = this._bounds.getSouth();\n  },\n\n  initProjector: function initProjector() {\n    if (this.isSupportedProjection(this.projection)) {\n      if (!proj4) {\n        throw 'proj4 must be found in the global scope in order to load a raster that uses a UTM projection';\n      }\n      this.projector = proj4(this.getProjectionString(this.projection), 'EPSG:' + EPSG4326);\n      if (this.debugLevel >= 1) console.log('projector set');\n    }\n  },\n\n  same: function same(array, key) {\n    return new Set(array.map(function (item) {\n      return item[key];\n    })).size === 1;\n  }\n});\n\nif (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n  module.exports = GeoRasterLayer;\n}\nif (typeof window !== 'undefined') {\n  window['GeoRasterLayer'] = GeoRasterLayer;\n} else if (typeof self !== 'undefined') {\n  self['GeoRasterLayer'] = GeoRasterLayer; // jshint ignore:line\n}\n"]},"metadata":{},"sourceType":"script"}